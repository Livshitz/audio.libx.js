<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>audio.libx.js - Basic Usage Example</title>
	<link rel="stylesheet" href="./shared/styles.css">
</head>

<body>
	<h1>audio.libx.js - Basic Usage Example</h1>

	<div class="container">
		<h2>Progressive Audio Streaming Demo</h2>
		<p>This example demonstrates the core features of audio.libx.js including progressive streaming, caching, and
			audio processing.</p>

		<audio id="audioPlayer" controls>
			Your browser does not support the audio element.
		</audio>

		<div class="controls">
			<input type="url" id="audioUrl" placeholder="Enter audio URL (MP3, WAV, etc.)"
				value="./files/jazz.wav">
			<button id="streamBtn">Stream Audio</button>
			<button id="playFromCacheBtn" disabled>Play from Cache</button>
			<button id="clearCacheBtn">Clear Cache</button>
		</div>

		<div class="controls">
			<label>Quick Examples:</label>
			<button
				onclick="document.getElementById('audioUrl').value='./files/jazz.wav'">WAV
				File (Fallback)</button>
			<button
				onclick="document.getElementById('audioUrl').value='./files/sorry.mp3'">MP3
				File (Streaming)</button>
		</div>

		<div class="progress">
			<div class="progress-bar" id="bufferProgress"></div>
		</div>

		<div id="status" class="status">Ready to stream audio...</div>
	</div>

	<div class="container">
		<h3>Statistics</h3>
		<div class="stats">
			<div class="stat-item">
				<div class="stat-value" id="cacheEntries">0</div>
				<div>Cache Entries</div>
			</div>
			<div class="stat-item">
				<div class="stat-value" id="cacheSize">0 MB</div>
				<div>Cache Size</div>
			</div>
			<div class="stat-item">
				<div class="stat-value" id="hitRatio">0%</div>
				<div>Cache Hit Ratio</div>
			</div>
			<div class="stat-item">
				<div class="stat-value" id="streamState">idle</div>
				<div>Stream State</div>
			</div>
		</div>
	</div>

	<div class="container">
		<h3>Event Log</h3>
		<div id="eventLog" class="log"></div>
		<button id="clearLogBtn">Clear Log</button>
	</div>

	<div class="container">
		<h3>Configuration</h3>
		<label>
			<input type="checkbox" id="enableCaching" checked> Enable Caching
		</label><br>
		<label>
			<input type="checkbox" id="enableTrimming" checked> Enable Silence Trimming
		</label><br>
		<label>
			Buffer Threshold: <input type="range" id="bufferThreshold" min="1" max="10" value="5">
			<span id="bufferThresholdValue">5</span>s
		</label>
	</div>

	<script type="module">
		// Import the library (in real usage, this would be from npm or CDN)
		import { createAudioStreamer } from '../build/index.js';
		import { logEvent, updateStatus, formatFileSize, formatDuration } from './shared/utils.js';

		// Get DOM elements
		const audioPlayer = document.getElementById('audioPlayer');
		const audioUrl = document.getElementById('audioUrl');
		const streamBtn = document.getElementById('streamBtn');
		const playFromCacheBtn = document.getElementById('playFromCacheBtn');
		const clearCacheBtn = document.getElementById('clearCacheBtn');
		const bufferProgress = document.getElementById('bufferProgress');
		const status = document.getElementById('status');
		const eventLog = document.getElementById('eventLog');
		const clearLogBtn = document.getElementById('clearLogBtn');

		// Stats elements
		const cacheEntries = document.getElementById('cacheEntries');
		const cacheSize = document.getElementById('cacheSize');
		const hitRatio = document.getElementById('hitRatio');
		const streamState = document.getElementById('streamState');

		// Config elements
		const enableCaching = document.getElementById('enableCaching');
		const enableTrimming = document.getElementById('enableTrimming');
		const bufferThreshold = document.getElementById('bufferThreshold');
		const bufferThresholdValue = document.getElementById('bufferThresholdValue');

		// State
		let streamer = null;
		let currentAudioId = null;

		// Initialize streamer with default options
		function initializeStreamer() {
			if (streamer) {
				streamer.dispose();
			}

			const options = {
				bufferThreshold: parseInt(bufferThreshold.value),
				enableCaching: enableCaching.checked,
				enableTrimming: enableTrimming.checked,
				silenceThresholdDb: -50,
				minSilenceMs: 100
			};

			streamer = createAudioStreamer(audioPlayer, options);

			// Set up event listeners
			streamer.on('stateChange', handleStateChange);
			streamer.on('bufferProgress', handleBufferProgress);
			streamer.on('canPlay', handleCanPlay);
			streamer.on('loadStart', handleLoadStart);
			streamer.on('loadEnd', handleLoadEnd);
			streamer.on('playStart', handlePlayStart);
			streamer.on('playEnd', handlePlayEnd);
			streamer.on('error', handleError);
			streamer.on('cacheHit', handleCacheHit);
			streamer.on('cacheMiss', handleCacheMiss);

			logEventLocal('Streamer initialized with options:', options);
		}

		// Event handlers
		function handleStateChange(event) {
			streamState.textContent = event.data.state;

			// Re-enable stream button when playback ends or goes idle
			if (event.data.state === 'ended' || event.data.state === 'idle') {
				streamBtn.disabled = false;
			}

			logEventLocal(`State changed to: ${event.data.state}`, event.data);
		}

		function handleBufferProgress(event) {
			const progress = Math.round(event.data * 100);
			bufferProgress.style.width = `${progress}%`;
			logEventLocal(`Buffer progress: ${progress}%`);
		}

		function handleCanPlay(event) {
			logEventLocal('Audio can play', event.audioId);
		}

		function handleLoadStart(event) {
			streamBtn.disabled = true;
			updateStatusLocal('Loading audio...', false);
			logEventLocal('Load started', event.audioId);
		}

		function handleLoadEnd(event) {
			streamBtn.disabled = false;
			if (currentAudioId) {
				playFromCacheBtn.disabled = false;
			}
			updateStatusLocal('Audio loaded successfully', false);
			logEventLocal('Load ended', event.audioId);
			updateStats();
		}

		function handlePlayStart(event) {
			updateStatusLocal('Playing audio...', false);
			logEventLocal('Playback started', event.audioId);
		}

		function handlePlayEnd(event) {
			streamBtn.disabled = false;
			updateStatusLocal('Playback finished', false);
			logEventLocal('Playback ended', event.audioId);
		}

		function handleError(event) {
			streamBtn.disabled = false;
			updateStatusLocal(`Error: ${event.data?.message || 'Unknown error'}`, true);
			logEventLocal('Error occurred:', event.data);
		}

		function handleCacheHit(event) {
			logEventLocal('Cache hit', event.audioId);
			updateStats();
		}

		function handleCacheMiss(event) {
			logEventLocal('Cache miss', event.audioId);
		}

		// UI helper functions
		const updateStatusLocal = (message, isError = false) => {
			updateStatus('status', message, isError ? 'error' : 'info');
		};

		const logEventLocal = (message, data = null) => {
			logEvent('eventLog', message, data);
		};

		async function updateStats() {
			if (!streamer) return;

			try {
				const capabilities = streamer.getCapabilities();
				if (capabilities.caching) {
					const stats = await streamer.getCacheStats();
					cacheEntries.textContent = stats.entryCount;
					cacheSize.textContent = formatFileSize(stats.totalSize);
					hitRatio.textContent = Math.round(stats.hitRatio * 100) + '%';
				} else {
					cacheEntries.textContent = 'N/A';
					cacheSize.textContent = 'N/A';
					hitRatio.textContent = 'N/A';
				}
			} catch (error) {
				logEventLocal('Failed to update stats:', error.message);
			}
		}

		// Button event handlers
		streamBtn.addEventListener('click', async () => {
			const url = audioUrl.value.trim();
			if (!url) {
				updateStatusLocal('Please enter a valid audio URL', true);
				return;
			}

			try {
				const result = await streamer.streamFromUrl(url);
				currentAudioId = result.audioId;

				// Wait for loading to complete
				await result.onLoaded;
				logEventLocal('Audio loaded and ready to play');

				// Optionally wait for playback to end
				result.onEnded.then(() => {
					logEventLocal('Playback completed');
				});

			} catch (error) {
				handleError({ data: error });
			}
		});

		playFromCacheBtn.addEventListener('click', async () => {
			if (!currentAudioId) {
				updateStatusLocal('No audio in cache to play', true);
				return;
			}

			try {
				const result = await streamer.playFromCache(currentAudioId);
				await result.onLoaded;
				logEventLocal('Playing from cache');
			} catch (error) {
				handleError({ data: error });
			}
		});

		clearCacheBtn.addEventListener('click', async () => {
			try {
				await streamer.clearCache();
				currentAudioId = null;
				playFromCacheBtn.disabled = true;
				updateStatusLocal('Cache cleared', false);
				logEventLocal('Cache cleared');
				updateStats();
			} catch (error) {
				handleError({ data: error });
			}
		});

		clearLogBtn.addEventListener('click', () => {
			eventLog.innerHTML = '';
		});

		// Config change handlers
		bufferThreshold.addEventListener('input', (e) => {
			bufferThresholdValue.textContent = e.target.value;
		});

		[enableCaching, enableTrimming, bufferThreshold].forEach(element => {
			element.addEventListener('change', () => {
				logEventLocal('Configuration changed, reinitializing streamer...');
				initializeStreamer();
			});
		});

		// Initialize on page load
		document.addEventListener('DOMContentLoaded', () => {
			initializeStreamer();
			updateStats();
			logEventLocal('Demo initialized');
		});

		// Cleanup on page unload
		window.addEventListener('beforeunload', () => {
			if (streamer) {
				streamer.dispose();
			}
		});
	</script>
</body>

</html>